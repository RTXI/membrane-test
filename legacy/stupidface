void MembraneTest::Panel::memTestCalculate( void ) {
double Vpp = pulseSize;
data_size = cnt;
if( data_size != data.size() ) // Check to make sure data size is correct
return ;

// Taken from electrophys_plugin, written by Jonathan Bettencourt
for(size_t i = 0;i<data_size;++i)
data[i] /= numStepsAvg;

double I1 = 0.0;
for(size_t i=static_cast<size_t>(round(data_size/2-ceil(data_size/8)));i<data_size/2;++i)
I1 += data[i];
I1 /= ceil(data_size/8);

double I2 = 0.0;
for(size_t i=static_cast<size_t>(round(data_size-ceil(data_size/8)));i<data_size;++i)
I2 += data[i];
I2 /= ceil(data_size/8);

double dt = RT::System::getInstance()->getPeriod() * 1e-6;

double Q11;
double tau1;
{
Q11 = 0.0;
for(size_t i=0;i<data_size/2-1;++i)
Q11 += dt*1e-3*(data[i]+data[i+1]-2*I1)/2;
Q11 = fabs(Q11);

size_t xi = 0;
for(;data[xi] <= data[xi+1];++xi);

double sy = 0.0;
double Y = data[xi];
double SY = sy;
double tSY = 0.0;
double YSY = data[xi]*sy;
double SYSY = sy*sy;
double t = 0.0;
double tt = 0.0;
double Yt = 0.0;
for(size_t i=xi+1;i<data_size/2;++i) {
sy += dt*1e-3*(data[i-1]+data[i])/2;

Y += data[i];
SY += sy;
tSY += (i-xi)*dt*1e-3*sy;
YSY += data[i]*sy;
SYSY += sy*sy;
t += (i-xi)*dt*1e-3;
tt += ((i-xi)*dt*1e-3)*((i-xi)*dt*1e-3);
Yt += (i-xi)*dt*1e-3*data[i];
}

double A[3*3] = {
data_size/2-xi,  SY,       t,
SY,           SYSY,     tSY,
t,            tSY,      tt,
};
double B[3] = {
Y,
YSY,
Yt,
};
double V[3*3];
double S[3];
double x[3];

gsl_matrix_view a = gsl_matrix_view_array(A,3,3);
gsl_matrix_view b = gsl_matrix_view_array(V,3,3);
gsl_vector_view c = gsl_vector_view_array(S,3);
gsl_vector_view d = gsl_vector_view_array(x,3);
gsl_vector_view e = gsl_vector_view_array(B,3);

gsl_linalg_SV_decomp(
&a.matrix,
&b.matrix,
&c.vector,
&d.vector
);
gsl_linalg_SV_solve(
&a.matrix,
&b.matrix,
&c.vector,
&e.vector,
&d.vector
);
tau1 = fabs(1.0/x[1]);
}

double Q12;
double tau2;
{
Q12 = 0.0;
for(size_t i=data_size/2;i<data_size;++i)
Q12 += dt*1e-3*(data[i]+data[i+1]-2*I2)/2;
Q12 = fabs(Q12);

size_t xi = data_size/2;
for(;data[xi] >= data[xi+1];++xi);

double sy = 0.0;
double Y = data[xi];
double SY = sy;
double tSY = 0.0;
double YSY = data[xi]*sy;
double SYSY = sy*sy;
double t = 0.0;
double tt = 0.0;
double Yt = 0.0;
for(size_t i=xi+1;i<data_size;++i) {
sy += dt*1e-3*(data[i-1]+data[i])/2;

Y += data[i];
SY += sy;
tSY += (i-xi)*dt*1e-3*sy;
YSY += data[i]*sy;
SYSY += sy*sy;
t += (i-xi)*dt*1e-3;
tt += ((i-xi)*dt*1e-3)*((i-xi)*dt*1e-3);
Yt += (i-xi)*dt*1e-3*data[i];
}

double A[3*3] = {
data_size-xi,  SY,       t,
SY,           SYSY,     tSY,
t,            tSY,      tt,
};
double B[3] = {
Y,
YSY,
Yt,
};
double V[3*3];
double S[3];
double x[3];

gsl_matrix_view a = gsl_matrix_view_array(A,3,3);
gsl_matrix_view b = gsl_matrix_view_array(V,3,3);
gsl_vector_view c = gsl_vector_view_array(S,3);
gsl_vector_view d = gsl_vector_view_array(x,3);
gsl_vector_view e = gsl_vector_view_array(B,3);

gsl_linalg_SV_decomp(
&a.matrix,
&b.matrix,
&c.vector,
&d.vector
);
gsl_linalg_SV_solve(
&a.matrix,
&b.matrix,
&c.vector,
&e.vector,
&d.vector
);
tau2 = fabs(1.0/x[1]);
}

double tau = (tau1+tau2)/2.0;

double Q1 = (Q11+Q12)/2.0;
double Q2 = fabs(I1-I2)*tau;
double Qt = Q1+Q2;

double Rt = Vpp*1e-3/fabs(I1-I2);

Ra = tau*Vpp*1e-3/Qt;
Rm = Rt-Ra;
Cm = Qt*Rt/(Vpp*1e-3*Rm);

Ra = round(Ra*1e-6*10)/10;
Rm = round(Rm*1e-6*10)/10;
Cm = round(Cm*1e12*10)/10;
}

